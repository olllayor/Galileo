<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MockRocket</title>
  <style>
    :root {
      color-scheme: light;
      font-family: "SF Pro Text", -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      background: #1d1d1d;
      color: #f5f5f5;
      overflow: hidden;
    }

    .app {
      display: flex;
      flex-direction: column;
      height: 100vh;
    }

    .topbar {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 14px;
      background: #2a2a2a;
      border-bottom: 1px solid #3a3a3a;
      flex-wrap: wrap;
      row-gap: 8px;
    }

    .brand {
      display: flex;
      align-items: center;
      gap: 8px;
      font-weight: 600;
      font-size: 13px;
      margin-right: 10px;
    }

    .brand-badge {
      width: 18px;
      height: 18px;
      border-radius: 5px;
      background: linear-gradient(135deg, #ff4bd8, #6b5bff);
    }

    .divider {
      width: 1px;
      height: 22px;
      background: #3a3a3a;
      margin: 0 4px;
    }

    .topbar button,
    .topbar select {
      border: 1px solid transparent;
      background: #3a3a3a;
      color: #f5f5f5;
      padding: 6px 10px;
      border-radius: 6px;
      font-size: 12px;
      cursor: pointer;
    }

    .topbar button.primary {
      background: #4f8ef7;
    }

    .topbar button.ghost {
      background: transparent;
      border: 1px solid #4a4a4a;
    }

    .topbar button.disabled {
      opacity: 0.6;
      cursor: default;
    }

    .status-inline {
      display: none;
    }

    .quality-control {
      display: flex;
      align-items: center;
      gap: 6px;
      flex-wrap: wrap;
    }

    .quality-label {
      font-size: 11px;
      color: #bdbdbd;
    }

    .quality-hint {
      font-size: 11px;
      color: #9b9b9b;
      white-space: nowrap;
    }

    .device-hint {
      margin-left: 6px;
      font-size: 11px;
      color: rgba(255, 255, 255, 0.4);
      cursor: help;
    }

    .loading-toast {
      position: fixed;
      top: 16px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 16px;
      border-radius: 999px;
      background: rgba(30, 30, 30, 0.95);
      border: 1px solid rgba(255, 255, 255, 0.12);
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.35);
      font-size: 13px;
      color: #f5f5f5;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease, transform 0.2s ease;
      z-index: 2000;
    }

    .loading-toast.visible {
      opacity: 1;
      transform: translateX(-50%) translateY(0);
    }

    .loading-toast.error {
      border-color: rgba(255, 99, 99, 0.5);
      color: #ffd6d6;
    }

    .loading-spinner {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      border: 2px solid rgba(255, 255, 255, 0.2);
      border-top-color: #ffffff;
      animation: spin 0.8s linear infinite;
      flex-shrink: 0;
    }

    .loading-toast.error .loading-spinner {
      display: none;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    .content {
      flex: 1;
      display: grid;
      grid-template-columns: minmax(0, 1fr) 280px;
      gap: 10px;
      padding: 10px;
      background: #262626;
    }

    .viewport {
      position: relative;
      border-radius: 12px;
      overflow: hidden;
      background: repeating-conic-gradient(#3b3b3b 0% 25%, #2d2d2d 0% 50%) 0% / 24px 24px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #glCanvas {
      width: 100%;
      height: 100%;
      display: block;
      cursor: grab;
    }

    #glCanvas.dragging {
      cursor: grabbing;
    }

    .viewport-overlay {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
      color: rgba(255, 255, 255, 0.7);
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    .sidebar {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .section {
      background: #1b1b1b;
      border-radius: 10px;
      padding: 10px;
      border: 1px solid #2c2c2c;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .label {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: rgba(255, 255, 255, 0.6);
    }

    .thumb {
      width: 100%;
      height: 88px;
      background: #121212;
      border-radius: 8px;
      border: 1px dashed #3a3a3a;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

    .thumb img {
      max-width: 100%;
      max-height: 100%;
    }

    .section button,
    .section select,
    .section input {
      width: 100%;
      padding: 6px 8px;
      border-radius: 6px;
      border: 1px solid #333333;
      background: #262626;
      color: #f5f5f5;
      font-size: 12px;
    }

    .position-row {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 6px;
    }

    .icon-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 6px;
      border-radius: 8px;
      border: 1px solid #333333;
      background: #262626;
      cursor: pointer;
    }

    .swatches {
      display: flex;
      gap: 6px;
    }

    .swatch {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      border: 2px solid #2c2c2c;
      cursor: pointer;
    }

    .toggle {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      font-size: 12px;
    }

    .toggle input {
      width: auto;
    }

    .status {
      font-size: 12px;
      color: rgba(255, 255, 255, 0.6);
      line-height: 1.3;
      max-height: 44px;
      overflow: hidden;
    }

    .status-inline {
      margin-left: auto;
      font-size: 12px;
      color: rgba(255, 255, 255, 0.6);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 220px;
    }

    .fit-btn {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 4px;
      padding: 8px 4px;
      border-radius: 6px;
      border: 1px solid #333333;
      background: #262626;
      color: rgba(255, 255, 255, 0.6);
      font-size: 10px;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .fit-btn:hover {
      background: #333333;
      color: #f5f5f5;
    }

    .fit-btn.active {
      background: #4f8ef7;
      border-color: #4f8ef7;
      color: #ffffff;
    }

    .fit-indicator-perfect {
      background: rgba(52, 199, 89, 0.2);
      color: #34c759;
      border: 1px solid rgba(52, 199, 89, 0.3);
    }

    .fit-indicator-good {
      background: rgba(79, 142, 247, 0.2);
      color: #4f8ef7;
      border: 1px solid rgba(79, 142, 247, 0.3);
    }

    .fit-indicator-info {
      background: rgba(255, 255, 255, 0.1);
      color: rgba(255, 255, 255, 0.7);
      border: 1px solid rgba(255, 255, 255, 0.15);
    }
  </style>
</head>

<body>
  <div class="app">
    <div class="topbar">
      <div class="brand">
        <span class="brand-badge"></span>
        MockRocket - 3D Mockups
      </div>
      <button id="loadSelection" class="primary">Load selection</button>
      <button class="ghost">Draw guide frame</button>
      <button class="disabled">Activate</button>
      <select id="scaleSelect">
        <option value="1">1x</option>
        <option value="2" selected>2x</option>
        <option value="3">3x</option>
      </select>
      <div class="quality-control">
        <span class="quality-label">Quality</span>
        <select id="qualitySelect">
          <option value="default" selected>Default</option>
          <option value="high">High</option>
          <option value="ultra">Ultra</option>
        </select>
        <span id="qualityHint" class="quality-hint"></span>
      </div>
      <div class="divider"></div>
      <button id="download">Download</button>
      <button id="insert" class="ghost">Export to Galileo</button>
      <div class="status-inline" id="status"></div>
    </div>
    <div class="content">
      <div class="viewport" id="viewport">
        <canvas id="glCanvas"></canvas>
        <div class="viewport-overlay" id="viewportOverlay">Drag to rotate</div>
      </div>
      <div class="sidebar">
        <div class="section">
          <div class="label">Selection</div>
          <div class="thumb">
            <img id="selectionPreview" alt="Selection preview" />
            <span id="selectionEmpty">Select a frame</span>
          </div>
          <div id="fitIndicator"
            style="display: none; padding: 4px 8px; margin-bottom: 6px; border-radius: 6px; font-size: 11px; text-align: center;">
          </div>
          <button id="refreshSelection">Refresh selection</button>
          <div class="label" style="margin-top: 8px;">Fit Mode</div>
          <div class="fit-mode-row" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 4px;">
            <button class="fit-btn" data-fit="contain" title="Contain - Show entire design">
              <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="3" y="6" width="18" height="12" rx="1" />
                <rect x="7" y="8" width="10" height="8" rx="0.5" fill="currentColor" opacity="0.3" />
              </svg>
              <span>Contain</span>
            </button>
            <button class="fit-btn" data-fit="cover" title="Cover - Fill screen (may crop)">
              <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="3" y="6" width="18" height="12" rx="1" />
                <rect x="3" y="6" width="18" height="12" rx="1" fill="currentColor" opacity="0.3" />
              </svg>
              <span>Cover</span>
            </button>
            <button class="fit-btn" data-fit="exact" title="Exact - No scaling">
              <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="3" y="6" width="18" height="12" rx="1" />
                <path d="M7 10h10M7 14h10" stroke="currentColor" stroke-width="1.5" />
              </svg>
              <span>Exact</span>
            </button>
          </div>
        </div>
        <div class="section">
          <div class="label">Device<span class="device-hint" title="Screen fit may vary by model">?</span></div>
          <select id="deviceSelect">
            <option value="iphone_15_pro_max">iPhone 15 Pro Max</option>
            <option value="iphone_16_free" selected>iPhone 16</option>
            <option value="iphone_17_air">iPhone 17 Air</option>
          </select>
          <div class="label">Position</div>
          <div class="position-row">
            <button class="icon-btn" data-rot="front" title="Front">
              <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#f5f5f5" stroke-width="2">
                <rect x="6" y="2" width="12" height="20" rx="3" />
              </svg>
            </button>
            <button class="icon-btn" data-rot="flat" title="Flat">
              <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#f5f5f5" stroke-width="2">
                <rect x="3" y="9" width="18" height="6" rx="2" />
              </svg>
            </button>
            <button class="icon-btn" data-rot="tilt" title="Tilt">
              <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#f5f5f5" stroke-width="2">
                <rect x="6" y="4" width="12" height="16" rx="3" transform="rotate(18 12 12)" />
              </svg>
            </button>
            <button class="icon-btn" data-rot="perspective" title="Perspective">
              <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#f5f5f5" stroke-width="2">
                <path d="M6 4h12l-2 16H8L6 4Z" />
              </svg>
            </button>
          </div>
          <div class="label">Colors</div>
          <div class="swatches">
            <div class="swatch" style="background:#1f1f1f;"></div>
            <div class="swatch" style="background:#707070;"></div>
            <div class="swatch" style="background:#cbb07b;"></div>
            <div class="swatch" style="background:#f5f5f5; border-color:#555;"></div>
            <div class="swatch" style="background:linear-gradient(135deg,#ff4bd8,#6b5bff);"></div>
          </div>
          <div class="toggle">
            <span>Clay device</span>
            <input type="checkbox" />
          </div>
          <div class="label">Environment</div>
          <div class="toggle">
            <span>Floor shadow</span>
            <input type="checkbox" />
          </div>
        </div>
      </div>
    </div>
  </div>
  <div id="loadingToast" class="loading-toast">
    <div class="loading-spinner"></div>
    <div id="loadingText">Loading…</div>
  </div>

  <script src="./lib/three.min.js?v=2"></script>
  <script src="./lib/DRACOLoader.legacy.js?v=2"></script>
  <script src="./lib/GLTFLoader.legacy.js?v=2"></script>
  <script>
    const { GLTFLoader, DRACOLoader } = THREE;

    const selectionPreview = document.getElementById('selectionPreview');
    const selectionEmpty = document.getElementById('selectionEmpty');
    const statusEl = document.getElementById('status');
    const scaleSelect = document.getElementById('scaleSelect');
    const qualitySelect = document.getElementById('qualitySelect');
    const qualityHint = document.getElementById('qualityHint');
    const deviceSelect = document.getElementById('deviceSelect');
    const viewportOverlay = document.getElementById('viewportOverlay');
    const glCanvas = document.getElementById('glCanvas');
    const viewport = document.getElementById('viewport');
    const loadingToast = document.getElementById('loadingToast');
    const loadingText = document.getElementById('loadingText');

    const pending = new Map();
    const rpc = {
      call(method, params) {
        const id = (crypto.randomUUID && crypto.randomUUID()) || `rpc_${Date.now()}_${Math.random()}`;
        const payload = { rpc: 1, id, method, params };
        window.parent.postMessage(payload, '*');
        return new Promise((resolve, reject) => {
          pending.set(id, { resolve, reject });
          setTimeout(() => {
            if (pending.has(id)) {
              pending.delete(id);
              reject(new Error('RPC timeout'));
            }
          }, 10000);
        });
      },
    };

    window.addEventListener('message', (event) => {
      const data = event.data;
      if (!data || data.rpc !== 1 || !data.id) return;
      const entry = pending.get(data.id);
      if (!entry) return;
      pending.delete(data.id);
      if (data.ok) {
        entry.resolve(data.result);
      } else {
        entry.reject(new Error(data.error?.message || 'RPC error'));
      }
    });

    const base64ToArrayBuffer = (base64) => {
      const binary = atob(base64);
      const len = binary.length;
      const bytes = new Uint8Array(len);
      for (let i = 0; i < len; i += 1) {
        bytes[i] = binary.charCodeAt(i);
      }
      return bytes.buffer;
    };

    const base64ToText = (base64) => {
      const binary = atob(base64);
      const len = binary.length;
      const bytes = new Uint8Array(len);
      for (let i = 0; i < len; i += 1) {
        bytes[i] = binary.charCodeAt(i);
      }
      return new TextDecoder('utf-8').decode(bytes);
    };

    const assetCache = new Map();

    const QUALITY_CAPS = {
      default: 4096,
      high: 6144,
      ultra: 8192,
    };

    const QUALITY_LABELS = {
      default: 'Default',
      high: 'High',
      ultra: 'Ultra',
    };

    const MEMORY_LIMIT_BYTES = 256 * 1024 * 1024;
    const MEMORY_LIMIT_PIXELS = 40_000_000;
    const MEMORY_CAP_DIM = Math.floor(Math.sqrt(Math.min(MEMORY_LIMIT_PIXELS, MEMORY_LIMIT_BYTES / 4)));
    const PREVIEW_CAP = 2048;

    const PRESET_CONFIGS = {
      iphone16: {
        id: 'iphone16',
        presetPath: 'presets/iphone16.json',
        screenConfigId: 'iphone16',
      },
    };

    const MODEL_CONFIGS = [
      {
        id: 'iphone_15_pro_max',
        label: 'iPhone 15 Pro Max',
        modelPath: 'models/iphone_15_pro_max.glb',
        presetId: 'iphone16',
        screenConfigId: 'iphone16',
        screenMaterialHints: ['glass', 'black'],
      },
      {
        id: 'iphone_16_free',
        label: 'iPhone 16 (Free)',
        modelPath: 'models/iphone_16_free.glb',
        presetId: 'iphone16',
        screenConfigId: 'iphone16',
        screenMaterialHints: ['screen', 'display'],
      },
      {
        id: 'iphone_17_air',
        label: 'iPhone 17 Air',
        modelPath: 'models/iphone_17_air.glb',
        presetId: 'iphone16',
        screenConfigId: 'iphone16',
        screenMaterialHints: ['17air_screen', 'screen'],
      },
      {
        id: 'iphone_17_pro',
        label: 'iPhone 17 Pro',
        modelPath: 'models/iphone_17_pro.glb',
        presetId: 'iphone16',
        screenConfigId: 'iphone16',
        screenMaterialHints: ['display', 'screen'],
      },
    ];

    const MODEL_CONFIG_MAP = MODEL_CONFIGS.reduce((acc, entry) => {
      acc[entry.id] = entry;
      return acc;
    }, {});

    const state = {
      selectionSnapshot: null,
      selectionTexture: null,
      selectionImage: null,
      selectionMeta: null,
      selectionFit: 'cover',
      selectionTargetAspect: null,
      modelScreenAspect: null,
      selectionToken: 0,
      hqSnapshotInfo: null,
      output: null,
      model: null,
      screenMesh: null,
      screenMeshTargets: [],
      renderer: null,
      scene: null,
      camera: null,
      preset: null,
      forceFastMode: null,
      envTexture: null,
      maxTextureSize: QUALITY_CAPS.default,
      activeModelId: 'iphone_16_free',
      activeModelConfig: null,
      screenConfigId: 'iphone16',
      qualityRequested: 'default',
      qualityTier: 'default',
      qualityCap: QUALITY_CAPS.default,
      qualityMaxAllowed: QUALITY_CAPS.default,
      qualityCapped: false,
      rotationX: -0.2,
      rotationY: -0.4,
      dragging: false,
      lastX: 0,
      lastY: 0,
      deviceMatch: null,
      loadingSelection: false,
    };

    const setStatus = (text) => {
      const message = (text || '').trim();
      const lower = message.toLowerCase();
      if (!message) {
        hideLoadingToast();
        statusEl.textContent = '';
        return;
      }
      if (lower.includes('loading') || lower.includes('preparing') || lower.includes('upgrading') || lower.includes('updating')) {
        showLoadingToast(message);
        return;
      }
      if (
        lower.includes('failed') ||
        lower.includes('error') ||
        lower.includes('timeout') ||
        lower.includes('not detected') ||
        lower.includes('cancel')
      ) {
        showToast(message, true);
        return;
      }
      hideLoadingToast();
      statusEl.textContent = '';
    };

    const showLoadingToast = (text) => {
      if (!loadingToast || !loadingText) return;
      loadingText.textContent = text;
      loadingToast.classList.remove('error');
      loadingToast.classList.add('visible');
    };

    const showToast = (text, isError) => {
      if (!loadingToast || !loadingText) return;
      loadingText.textContent = text;
      loadingToast.classList.toggle('error', Boolean(isError));
      loadingToast.classList.add('visible');
      window.clearTimeout(showToast._hideTimer);
      showToast._hideTimer = window.setTimeout(() => {
        hideLoadingToast();
      }, isError ? 3200 : 2000);
    };
    showToast._hideTimer = null;

    const hideLoadingToast = () => {
      if (!loadingToast) return;
      loadingToast.classList.remove('visible');
      loadingToast.classList.remove('error');
    };

    setStatus('Ready');

    const resolveQualityCap = (requested) => {
      const maxTexture = state.maxTextureSize || QUALITY_CAPS.default;
      const maxAllowed = Math.min(maxTexture, MEMORY_CAP_DIM);
      let tier = requested;

      if (requested === 'ultra') {
        if (QUALITY_CAPS.ultra > maxAllowed) {
          tier = QUALITY_CAPS.high <= maxAllowed ? 'high' : 'default';
        }
      } else if (requested === 'high') {
        if (QUALITY_CAPS.high > maxAllowed) {
          tier = 'default';
        }
      }

      const cap = Math.min(QUALITY_CAPS[tier], maxAllowed);
      return { requested, tier, cap, maxAllowed };
    };

    const updateQualityState = (requested = (qualitySelect && qualitySelect.value) || 'default') => {
      if (!state.selectionMeta) {
        state.qualityCapped = false;
      }
      const result = resolveQualityCap(requested);
      state.qualityRequested = requested;
      state.qualityTier = result.tier;
      state.qualityCap = result.cap;
      state.qualityMaxAllowed = result.maxAllowed;

      if (qualityHint) {
        const hintParts = [];
        if (result.requested !== result.tier) {
          hintParts.push(`${QUALITY_LABELS[result.requested]} unavailable → using ${QUALITY_LABELS[result.tier]}`);
        }
        if (result.tier !== 'default') {
          hintParts.push('May use more memory / slower');
        }
        if (state.qualityCapped) {
          hintParts.push(`Screen sharpness capped at ${state.qualityCap}px`);
        }
        hintParts.push('Capped by GPU max texture size');
        qualityHint.textContent = hintParts.join(' · ');
      }

      if (result.requested !== result.tier) {
        setStatus(`${QUALITY_LABELS[result.requested]} unavailable → using ${QUALITY_LABELS[result.tier]}`);
      }
    };

    updateQualityState();

    const loadAsset = async (ref) => {
      if (!ref || !ref.scope || !ref.path) {
        throw new Error('Invalid asset reference');
      }
      const key = `${ref.scope}:${ref.path}`;
      if (assetCache.has(key)) return assetCache.get(key);
      const asset = await rpc.call('asset.load', {
        scope: ref.scope,
        path: ref.path,
        encoding: 'base64',
      });
      assetCache.set(key, asset);
      return asset;
    };

    const loadJsonAsset = async (ref) => {
      const asset = await loadAsset(ref);
      const text = base64ToText(asset.dataBase64);
      return JSON.parse(text);
    };

    const loadImageFromDataUrl = (dataUrl) => {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.onerror = () => reject(new Error('Failed to load image'));
        img.src = dataUrl;
      });
    };

    const loadImageAsset = async (ref) => {
      const asset = await loadAsset(ref);
      const dataUrl = `data:${asset.mime};base64,${asset.dataBase64}`;
      return loadImageFromDataUrl(dataUrl);
    };

    const decodeHDR = (buffer) => {
      const bytes = new Uint8Array(buffer);
      let offset = 0;

      const readLine = () => {
        let line = '';
        while (offset < bytes.length) {
          const char = bytes[offset++];
          if (char === 10) break;
          if (char === 13) continue;
          line += String.fromCharCode(char);
        }
        return line;
      };

      let line = '';
      while (offset < bytes.length) {
        line = readLine();
        if (line === '') break;
      }

      const resolution = readLine();
      const match = resolution.match(/-Y\\s+(\\d+)\\s+\\+X\\s+(\\d+)/i)
        || resolution.match(/\\+Y\\s+(\\d+)\\s+\\+X\\s+(\\d+)/i);
      if (!match) {
        throw new Error('Invalid HDR resolution');
      }
      const height = Number(match[1]);
      const width = Number(match[2]);

      const rgbe = new Uint8Array(width * height * 4);
      let ptr = 0;

      for (let y = 0; y < height; y += 1) {
        if (
          offset + 4 <= bytes.length
          && bytes[offset] === 2
          && bytes[offset + 1] === 2
        ) {
          const scanlineWidth = (bytes[offset + 2] << 8) | bytes[offset + 3];
          if (scanlineWidth !== width) {
            throw new Error('HDR scanline width mismatch');
          }
          offset += 4;
          const scanline = new Uint8Array(width * 4);
          for (let channel = 0; channel < 4; channel += 1) {
            let i = 0;
            while (i < width) {
              const count = bytes[offset++];
              if (count > 128) {
                const run = count - 128;
                const value = bytes[offset++];
                for (let r = 0; r < run; r += 1) {
                  scanline[channel * width + i++] = value;
                }
              } else {
                for (let r = 0; r < count; r += 1) {
                  scanline[channel * width + i++] = bytes[offset++];
                }
              }
            }
          }
          for (let x = 0; x < width; x += 1) {
            rgbe[ptr++] = scanline[x];
            rgbe[ptr++] = scanline[width + x];
            rgbe[ptr++] = scanline[width * 2 + x];
            rgbe[ptr++] = scanline[width * 3 + x];
          }
        } else {
          const remaining = width * 4;
          rgbe.set(bytes.subarray(offset, offset + remaining), ptr);
          offset += remaining;
          ptr += remaining;
        }
      }

      return { width, height, data: rgbe };
    };

    const createEnvironmentTexture = (hdr) => {
      const { width, height, data } = hdr;
      const ldr = new Uint8Array(width * height * 4);
      const exposure = 1.0;
      for (let i = 0; i < data.length; i += 4) {
        const e = data[i + 3];
        let r = 0;
        let g = 0;
        let b = 0;
        if (e !== 0) {
          const scale = Math.pow(2, e - 128) / 255;
          r = data[i] * scale * exposure;
          g = data[i + 1] * scale * exposure;
          b = data[i + 2] * scale * exposure;
        }
        const idx = i;
        ldr[idx] = Math.max(0, Math.min(255, Math.round(r * 255)));
        ldr[idx + 1] = Math.max(0, Math.min(255, Math.round(g * 255)));
        ldr[idx + 2] = Math.max(0, Math.min(255, Math.round(b * 255)));
        ldr[idx + 3] = 255;
      }
      const texture = new THREE.DataTexture(ldr, width, height, THREE.RGBAFormat);
      texture.mapping = THREE.EquirectangularReflectionMapping;
      texture.colorSpace = THREE.SRGBColorSpace;
      texture.needsUpdate = true;
      return texture;
    };

    const applyEnvironment = async (envRef) => {
      if (!envRef || !state.scene) return;
      try {
        const asset = await loadAsset(envRef);
        const buffer = base64ToArrayBuffer(asset.dataBase64);
        let texture = null;
        if (envRef.path.endsWith('.hdr')) {
          const hdr = decodeHDR(buffer);
          texture = createEnvironmentTexture(hdr);
        } else {
          const dataUrl = `data:${asset.mime};base64,${asset.dataBase64}`;
          const img = await loadImageFromDataUrl(dataUrl);
          texture = new THREE.Texture(img);
          texture.mapping = THREE.EquirectangularReflectionMapping;
          texture.colorSpace = THREE.SRGBColorSpace;
          texture.needsUpdate = true;
        }
        state.envTexture = texture;
        state.scene.environment = texture;
      } catch (error) {
        console.warn('Failed to load environment', error);
      }
    };

    const parseFastVariant = (value) => {
      if (!value) return null;
      const parts = value.split('.');
      if (parts.length === 2) return parts[1];
      return value;
    };

    const getFallbackVariant = () => {
      const fallback = state.preset?.fallback?.on3dError || 'fast.tilt';
      return parseFastVariant(fallback) || 'tilt';
    };

    const loadPreset = async (presetId = state.screenConfigId || 'iphone16') => {
      const config = PRESET_CONFIGS[presetId] || PRESET_CONFIGS.iphone16;
      const preset = await loadJsonAsset({ scope: 'bundle', path: config.presetPath });
      state.preset = preset;
      state.screenConfigId = config.screenConfigId || presetId;
      if (preset?.defaultMode === 'fast' || preset?.ui?.fastModeDefault) {
        state.forceFastMode = getFallbackVariant();
      }
      if (preset?.three?.camera?.orbit) {
        state.rotationX = preset.three.camera.orbit.x ?? state.rotationX;
        state.rotationY = preset.three.camera.orbit.y ?? state.rotationY;
      }
      if (state.camera && preset?.three?.camera?.fov) {
        state.camera.fov = preset.three.camera.fov;
        state.camera.updateProjectionMatrix();
      }
      return preset;
    };

    const getMaterialNames = (material) => {
      if (!material) return '';
      const materials = Array.isArray(material) ? material : [material];
      return materials.map((mat) => mat?.name || '').filter(Boolean).join(' ').toLowerCase();
    };

    const getScreenKeywordScore = (name, matName) => {
      const text = `${name} ${matName}`;
      let score = 0;
      if (text.includes('screen')) score += 3;
      if (text.includes('display')) score += 2.5;
      if (text.includes('lcd')) score += 2;
      if (text.includes('glass')) score += 1;
      if (text.includes('front')) score += 0.5;
      return score;
    };

    const getScreenHintScore = (name, matName) => {
      const hints = state.activeModelConfig?.screenMaterialHints || [];
      if (!hints.length) return 0;
      const text = `${name} ${matName}`;
      let score = 0;
      hints.forEach((hint) => {
        const needle = String(hint || '').toLowerCase().trim();
        if (!needle) return;
        if (text.includes(needle)) {
          score += 6;
        }
      });
      return score;
    };

    const pickScreenMeshByPlane = (root) => {
      if (!root) return null;
      const expectedAspect = state.preset?.three?.screen?.expectedAspect ?? 2.15;
      const minAreaRatio = state.preset?.three?.screen?.minAreaRatio ?? 0.05;
      const modelBox = new THREE.Box3().setFromObject(root);
      const modelSize = new THREE.Vector3();
      modelBox.getSize(modelSize);
      const modelDims = [modelSize.x, modelSize.y, modelSize.z].sort((a, b) => b - a);
      const modelFaceArea = Math.max(1e-6, modelDims[0] * modelDims[1]);
      const minDimension = Math.max(0.05, modelDims[0] * 0.06);

      let best = null;
      let bestScore = -Infinity;
      let bestAspectScore = 0;

      root.traverse((child) => {
        if (!child.isMesh) return;
        const box = new THREE.Box3().setFromObject(child);
        const size = new THREE.Vector3();
        box.getSize(size);
        const dims = [size.x, size.y, size.z].sort((a, b) => b - a);
        const area = dims[0] * dims[1];
        if (!isFinite(area) || area <= 0) return;
        if (dims[0] < minDimension || dims[1] < minDimension) return;
        if (area / modelFaceArea < minAreaRatio) return;

        const aspect = dims[0] / Math.max(1e-4, dims[1]);
        const aspectScore = 1 / (1 + Math.abs(aspect - expectedAspect));
        const thickness = dims[2];
        const thicknessRatio = thickness / Math.max(1e-6, dims[0]);
        const flatness = 1 / (1 + thicknessRatio * 50);
        const score = area * aspectScore * flatness;

        if (score > bestScore) {
          bestScore = score;
          best = child;
          bestAspectScore = aspectScore;
        }
      });

      return best ? { mesh: best, score: bestScore, aspectScore: bestAspectScore } : null;
    };

    const findScreenMesh = (root) => {
      const candidates = [];
      const expectedAspect = state.preset?.three?.screen?.expectedAspect ?? 2.15;
      const planeCandidate = pickScreenMeshByPlane(root);
      root.traverse((child) => {
        if (!child.isMesh) return;
        const name = (child.name || '').toLowerCase();
        const matName = getMaterialNames(child.material);
        const keywordScore = getScreenKeywordScore(name, matName);
        const hintScore = getScreenHintScore(name, matName);
        const combinedScore = keywordScore + hintScore;
        if (combinedScore <= 0) return;
        const box = new THREE.Box3().setFromObject(child);
        const size = new THREE.Vector3();
        box.getSize(size);
        const dims = [size.x, size.y, size.z].sort((a, b) => b - a);
        const area = dims[0] * dims[1];
        const aspect = dims[0] / Math.max(1e-4, dims[1]);
        const aspectScore = 1 / (1 + Math.abs(aspect - expectedAspect));
        const score = combinedScore * 1000 + area * aspectScore;
        candidates.push({ mesh: child, score });
      });
      if (candidates.length > 0) {
        candidates.sort((a, b) => b.score - a.score);
        if (planeCandidate?.mesh) {
          const bestAspect = getScreenAspect(candidates[0].mesh);
          const bestAspectScore = bestAspect
            ? 1 / (1 + Math.abs(bestAspect - expectedAspect))
            : 0;
          if (planeCandidate.aspectScore > bestAspectScore + 0.15) {
            state.screenMeshTargets = [planeCandidate.mesh];
            return planeCandidate.mesh;
          }
        }
        const bestScore = candidates[0].score;
        const threshold = bestScore * 0.7;
        const targets = candidates.filter((c) => c.score >= threshold).map((c) => c.mesh);
        state.screenMeshTargets = targets;
        return candidates[0].mesh;
      }
      if (planeCandidate?.mesh) {
        state.screenMeshTargets = [planeCandidate.mesh];
        return planeCandidate.mesh;
      }
      state.screenMeshTargets = [];
      const fallback = pickScreenMeshByGeometry(root);
      state.screenMeshTargets = fallback ? [fallback] : [];
      return fallback;
    };

    const pickScreenMeshByGeometry = (root) => {
      if (!state.camera) return null;
      const modelBox = new THREE.Box3().setFromObject(root);
      const modelCenter = new THREE.Vector3();
      modelBox.getCenter(modelCenter);
      const modelSize = new THREE.Vector3();
      modelBox.getSize(modelSize);
      const modelDims = [modelSize.x, modelSize.y, modelSize.z].sort((a, b) => b - a);
      const modelFaceArea = Math.max(1e-6, modelDims[0] * modelDims[1]);
      const cameraDir = new THREE.Vector3()
        .subVectors(state.camera.position, modelCenter)
        .normalize();

      let best = null;
      let bestScore = -Infinity;
      const expectedAspect = state.preset?.three?.screen?.expectedAspect ?? 2.15;
      // minAreaRatio is the ratio of screen mesh projected area to overall device projected area.
      const minAreaRatio = state.preset?.three?.screen?.minAreaRatio ?? 0.05;

      root.traverse((child) => {
        if (!child.isMesh) return;
        const box = new THREE.Box3().setFromObject(child);
        const size = new THREE.Vector3();
        box.getSize(size);
        const dims = [size.x, size.y, size.z].sort((a, b) => b - a);
        const area = dims[0] * dims[1];
        const thickness = dims[2];
        if (!isFinite(area) || area <= 0) return;
        if (!isFinite(thickness) || thickness <= 0) return;
        if (dims[0] < 0.2 || dims[1] < 0.2) return;
        if (thickness > dims[0] * 0.4) return;
        if (area / modelFaceArea < minAreaRatio) return;

        const center = new THREE.Vector3();
        box.getCenter(center);
        const fromCenter = new THREE.Vector3().subVectors(center, modelCenter).normalize();
        const towardCamera = Math.max(0, cameraDir.dot(fromCenter));

        const aspect = dims[0] / Math.max(1e-4, dims[1]);
        const aspectScore = 1 / (1 + Math.abs(aspect - expectedAspect));

        const score = (area / Math.max(thickness, 1e-3)) * (1 + towardCamera * 1.5) * aspectScore;
        if (score > bestScore) {
          bestScore = score;
          best = child;
        }
      });

      return best;
    };

    const generatePlanarUVs = (mesh) => {
      const geom = mesh?.geometry;
      if (!geom || !geom.attributes?.position) return false;
      geom.computeBoundingBox();
      const bbox = geom.boundingBox;
      if (!bbox) return false;

      const size = new THREE.Vector3();
      bbox.getSize(size);
      const axes = [
        { axis: 'x', size: size.x },
        { axis: 'y', size: size.y },
        { axis: 'z', size: size.z },
      ].sort((a, b) => b.size - a.size);
      const uAxis = axes[0].axis;
      const vAxis = axes[1].axis;

      const minU = bbox.min[uAxis];
      const maxU = bbox.max[uAxis];
      const minV = bbox.min[vAxis];
      const maxV = bbox.max[vAxis];
      const rangeU = Math.max(1e-6, maxU - minU);
      const rangeV = Math.max(1e-6, maxV - minV);

      const pos = geom.attributes.position;
      const uvArray = new Float32Array(pos.count * 2);

      const getCoord = (i, axis) => {
        if (axis === 'x') return pos.getX(i);
        if (axis === 'y') return pos.getY(i);
        return pos.getZ(i);
      };

      for (let i = 0; i < pos.count; i += 1) {
        const u = (getCoord(i, uAxis) - minU) / rangeU;
        const v = (getCoord(i, vAxis) - minV) / rangeV;
        uvArray[i * 2] = u;
        uvArray[i * 2 + 1] = 1 - v;
      }

      geom.setAttribute('uv', new THREE.BufferAttribute(uvArray, 2));
      geom.attributes.uv.needsUpdate = true;
      return true;
    };

    const normalizeScreenUVs = (mesh) => {
      if (!mesh?.geometry) return null;
      if (mesh.userData?.uvNormalization) {
        return mesh.userData.uvNormalization;
      }
      const geom = mesh.geometry;
      const uv = geom.attributes?.uv;
      if (!uv || uv.count === 0) {
        generatePlanarUVs(mesh);
        const info = { repeatX: 1, repeatY: 1, offsetX: 0, offsetY: 0 };
        mesh.userData.uvNormalization = info;
        return info;
      }

      let minU = Infinity;
      let minV = Infinity;
      let maxU = -Infinity;
      let maxV = -Infinity;
      for (let i = 0; i < uv.count; i += 1) {
        const u = uv.getX(i);
        const v = uv.getY(i);
        if (!Number.isFinite(u) || !Number.isFinite(v)) continue;
        minU = Math.min(minU, u);
        minV = Math.min(minV, v);
        maxU = Math.max(maxU, u);
        maxV = Math.max(maxV, v);
      }
      const rangeU = maxU - minU;
      const rangeV = maxV - minV;
      if (!Number.isFinite(rangeU) || !Number.isFinite(rangeV) || rangeU < 1e-4 || rangeV < 1e-4) {
        generatePlanarUVs(mesh);
        const info = { repeatX: 1, repeatY: 1, offsetX: 0, offsetY: 0 };
        mesh.userData.uvNormalization = info;
        return info;
      }
      const repeatX = 1 / rangeU;
      const repeatY = 1 / rangeV;
      const offsetX = -minU * repeatX;
      const offsetY = -minV * repeatY;
      const info = { repeatX, repeatY, offsetX, offsetY };
      mesh.userData.uvNormalization = info;
      return info;
    };

    const applyTextureToMesh = (mesh, texture) => {
      if (!mesh || !texture) return;
      const uvInfo = normalizeScreenUVs(mesh);
      if (uvInfo) {
        texture.offset.set(uvInfo.offsetX, uvInfo.offsetY);
        texture.repeat.set(uvInfo.repeatX, uvInfo.repeatY);
        texture.needsUpdate = true;
      }
      const materials = Array.isArray(mesh.material) ? mesh.material : [mesh.material];
      materials.forEach((material) => {
        if (!material) return;
        material.map = texture;
        if ('color' in material) {
          material.color = new THREE.Color(0xffffff);
        }
        if ('transparent' in material) {
          material.transparent = false;
          material.opacity = 1;
        }
        if ('emissive' in material) {
          material.emissive = new THREE.Color(0xffffff);
          material.emissiveMap = texture;
          material.emissiveIntensity = 1;
        }
        material.needsUpdate = true;
      });
    };

    const applyTextureToMeshes = (meshes, texture) => {
      if (!meshes || !texture) return;
      const list = Array.isArray(meshes) ? meshes : [meshes];
      list.forEach((mesh) => applyTextureToMesh(mesh, texture));
    };

    const setupScene = () => {
      const renderer = new THREE.WebGLRenderer({
        canvas: glCanvas,
        antialias: true,
        alpha: true,
        preserveDrawingBuffer: true,
        powerPreference: 'high-performance',
      });
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      // Use higher pixel ratio for better quality (capped at 2 for performance)
      renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
      // Enable tone mapping for better color reproduction
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.0;

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 2000);
      camera.position.set(0, 0, 5);

      const ambient = new THREE.AmbientLight(0xffffff, 0.9);
      const hemisphere = new THREE.HemisphereLight(0xffffff, 0x333333, 0.6);
      const directional = new THREE.DirectionalLight(0xffffff, 1.4);
      directional.position.set(2, 3, 5);
      scene.add(ambient, hemisphere, directional);

      state.renderer = renderer;
      state.scene = scene;
      state.camera = camera;
      state.maxTextureSize = renderer.capabilities?.maxTextureSize || QUALITY_CAPS.default;
      updateQualityState(state.qualityRequested);
    };

    const fitCameraToObject = (object, offset = 1.6) => {
      const box = new THREE.Box3().setFromObject(object);
      const size = new THREE.Vector3();
      box.getSize(size);
      const center = new THREE.Vector3();
      box.getCenter(center);
      const maxDim = Math.max(size.x, size.y, size.z);
      const fov = state.camera.fov * (Math.PI / 180);
      let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
      cameraZ *= offset;
      state.camera.position.set(center.x, center.y, center.z + cameraZ);
      state.camera.near = Math.max(0.1, maxDim / 100);
      state.camera.far = Math.max(1000, maxDim * 10);
      state.camera.lookAt(center);
      state.camera.updateProjectionMatrix();
    };

    const createFallbackModel = () => {
      const geometry = new THREE.BoxGeometry(1, 2, 0.1);
      const material = new THREE.MeshStandardMaterial({ color: 0x5566ff });
      const mesh = new THREE.Mesh(geometry, material);
      mesh.name = 'fallback_phone';
      return mesh;
    };

    const disposeModel = (model) => {
      if (!model) return;
      model.traverse((child) => {
        if (!child.isMesh) return;
        if (child.geometry) {
          child.geometry.dispose();
        }
        if (child.material) {
          const materials = Array.isArray(child.material) ? child.material : [child.material];
          materials.forEach((mat) => {
            if (!mat) return;
            if (mat.map) mat.map.dispose();
            if (mat.emissiveMap) mat.emissiveMap.dispose();
            if (mat.normalMap) mat.normalMap.dispose();
            if (mat.roughnessMap) mat.roughnessMap.dispose();
            if (mat.metalnessMap) mat.metalnessMap.dispose();
            mat.dispose();
          });
        }
      });
    };

    const loadModel = async (modelConfig = state.activeModelConfig) => {
      const loader = new GLTFLoader();
      const draco = new DRACOLoader();
      draco.setDecoderPath(new URL('./lib/draco/', window.location.href).href);
      loader.setDRACOLoader(draco);
      try {
        setStatus('Loading model...');
        state.forceFastMode = null;
        state.modelScreenAspect = null;
        const fallbackModelRef = { scope: 'bundle', path: modelConfig?.modelPath || 'models/iphone_16_free.glb' };
        const modelRef = modelConfig?.modelPath
          ? { scope: 'bundle', path: modelConfig.modelPath }
          : state.preset?.three?.model;
        let asset;
        if (modelRef) {
          try {
            asset = await loadAsset(modelRef);
          } catch (error) {
            console.warn('Failed to load model, using fallback', error);
            asset = await loadAsset(fallbackModelRef);
          }
        } else {
          asset = await loadAsset(fallbackModelRef);
        }
        const buffer = base64ToArrayBuffer(asset.dataBase64);
        const gltf = await new Promise((resolve, reject) => {
          loader.parse(buffer, '', resolve, reject);
        });
        const model = gltf.scene || gltf.scenes?.[0];
        if (!model) {
          throw new Error('GLB scene is empty');
        }

        if (state.model && state.scene) {
          state.scene.remove(state.model);
          disposeModel(state.model);
          state.model = null;
          state.screenMesh = null;
        }

        const box = new THREE.Box3().setFromObject(model);
        const size = new THREE.Vector3();
        box.getSize(size);
        const center = new THREE.Vector3();
        box.getCenter(center);
        model.position.sub(center);

        let meshCount = 0;
        model.traverse((child) => {
          if (!child.isMesh) return;
          meshCount += 1;
          child.frustumCulled = false;
          if (child.material) {
            const materials = Array.isArray(child.material) ? child.material : [child.material];
            materials.forEach((mat) => {
              if (!mat) return;
              mat.side = THREE.DoubleSide;
              mat.needsUpdate = true;
            });
          }
        });

        state.model = model;
        state.scene.add(model);

        state.screenMesh = findScreenMesh(model);
        if (!state.screenMesh) {
          state.modelScreenAspect = null;
          state.forceFastMode = parseFastVariant(state.preset?.fallback?.onNoScreen || 'fast.tilt');
          setStatus('Screen mesh not detected. Using Fast mode.');
        } else if (state.selectionTexture) {
          state.modelScreenAspect = getScreenAspect(state.screenMesh);
          const targets = state.screenMeshTargets?.length ? state.screenMeshTargets : state.screenMesh;
          applyTextureToMeshes(targets, state.selectionTexture);
        } else {
          state.modelScreenAspect = getScreenAspect(state.screenMesh);
        }

        fitCameraToObject(model, state.preset?.three?.camera?.fit ?? 1.6);
        await applyEnvironment(state.preset?.three?.env);
        setStatus(meshCount > 0 ? 'Model loaded.' : 'Model loaded, but no meshes found.');
        return;
      } catch (error) {
        console.error('Failed to load GLB', error);
        if (!state.model) {
          const fallback = createFallbackModel();
          state.model = fallback;
          state.scene.add(fallback);
          fitCameraToObject(fallback, state.preset?.three?.camera?.fit ?? 1.6);
        }
        state.forceFastMode = parseFastVariant(state.preset?.fallback?.on3dError || 'fast.tilt');
        const message = error instanceof Error ? error.message : 'Failed to load model.';
        setStatus(`${message} Using Fast mode.`);
      }
    };

    const updateCamera = () => {
      const width = viewport.clientWidth;
      const height = viewport.clientHeight;
      state.renderer.setSize(width, height, false);
      state.camera.aspect = width / height;
      state.camera.updateProjectionMatrix();
    };

    const render = () => {
      if (!state.renderer || !state.scene || !state.camera) return;
      if (state.model) {
        state.model.rotation.set(state.rotationX, state.rotationY, 0);
      }
      state.renderer.render(state.scene, state.camera);
    };

    const animate = () => {
      render();
      requestAnimationFrame(animate);
    };

    const createImageFromSnapshot = async (snapshot) => {
      const dataUrl = `data:${snapshot.mime};base64,${snapshot.dataBase64}`;
      return loadImageFromDataUrl(dataUrl);
    };

    const getScreenAspect = (mesh) => {
      if (!mesh) return null;
      const box = new THREE.Box3().setFromObject(mesh);
      const size = new THREE.Vector3();
      box.getSize(size);
      const dims = [size.x, size.y, size.z].sort((a, b) => b - a);
      const width = dims[0] || 1;
      const height = dims[1] || 1;
      return width / height;
    };

    const isPowerOfTwo = (value) => (value & (value - 1)) === 0 && value !== 0;

    const getTargetScreenAspect = (devicePresetId) => {
      if (devicePresetId && DEVICE_ASPECTS[devicePresetId]) {
        return DEVICE_ASPECTS[devicePresetId];
      }
      if (state.preset?.three?.screen?.expectedAspect) {
        return state.preset.three.screen.expectedAspect;
      }
      return getScreenAspect(state.screenMesh);
    };

    const getFitAspect = (aspect) => {
      if (!aspect || !isFinite(aspect)) return null;
      return aspect >= 1 ? 1 / aspect : aspect;
    };

    const createTextureFromSnapshot = async (snapshot, fitMode, targetAspect) => {
      const img = state.selectionImage || await createImageFromSnapshot(snapshot);
      let source = img;
      if (fitMode !== 'exact') {
        const aspect = targetAspect || getScreenAspect(state.screenMesh);
        const fitAspect = getFitAspect(aspect);
        if (fitAspect) {
          source = createFitCanvasForAspect(img, fitAspect, fitMode || 'cover');
        }
      }
      const texture = new THREE.Texture(source);
      texture.colorSpace = THREE.SRGBColorSpace;
      texture.wrapS = THREE.ClampToEdgeWrapping;
      texture.wrapT = THREE.ClampToEdgeWrapping;
      const canMipmap = isPowerOfTwo(source.width) && isPowerOfTwo(source.height);
      // High-quality texture filtering settings
      texture.minFilter = canMipmap ? THREE.LinearMipmapLinearFilter : THREE.LinearFilter;
      texture.magFilter = THREE.LinearFilter;
      texture.generateMipmaps = canMipmap;
      const maxAnisotropy = state.renderer?.capabilities?.getMaxAnisotropy?.() || 1;
      texture.anisotropy = Math.min(8, maxAnisotropy);
      texture.needsUpdate = true;
      texture.flipY = false;
      return texture;
    };

    const drawImageCover = (ctx, img, rect) => {
      const padding = rect.padding || 0;
      const x = rect.x + padding;
      const y = rect.y + padding;
      const w = rect.w - padding * 2;
      const h = rect.h - padding * 2;
      const scale = Math.max(w / img.width, h / img.height);
      const drawW = img.width * scale;
      const drawH = img.height * scale;
      const dx = x + (w - drawW) / 2;
      const dy = y + (h - drawH) / 2;
      // Enable high-quality image smoothing
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
      ctx.drawImage(img, dx, dy, drawW, drawH);
    };

    const drawImageContain = (ctx, img, rect) => {
      const padding = rect.padding || 0;
      const x = rect.x + padding;
      const y = rect.y + padding;
      const w = rect.w - padding * 2;
      const h = rect.h - padding * 2;
      const scale = Math.min(w / img.width, h / img.height);
      const drawW = img.width * scale;
      const drawH = img.height * scale;
      const dx = x + (w - drawW) / 2;
      const dy = y + (h - drawH) / 2;
      // Enable high-quality image smoothing
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
      ctx.drawImage(img, dx, dy, drawW, drawH);
    };

    const createCoverCanvas = (img, width, height) => {
      const canvas = document.createElement('canvas');
      canvas.width = Math.max(1, Math.round(width));
      canvas.height = Math.max(1, Math.round(height));
      const ctx = canvas.getContext('2d');
      if (!ctx) return canvas;
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
      drawImageCover(ctx, img, { x: 0, y: 0, w: canvas.width, h: canvas.height, padding: 0 });
      return canvas;
    };

    const createContainCanvas = (img, width, height) => {
      const canvas = document.createElement('canvas');
      canvas.width = Math.max(1, Math.round(width));
      canvas.height = Math.max(1, Math.round(height));
      const ctx = canvas.getContext('2d');
      if (!ctx) return canvas;
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
      drawImageContain(ctx, img, { x: 0, y: 0, w: canvas.width, h: canvas.height, padding: 0 });
      return canvas;
    };

    const createFitCanvasForAspect = (img, aspect, mode) => {
      if (!aspect || !isFinite(aspect)) return img;
      const imgW = img.width || 1;
      const imgH = img.height || 1;
      const imgAspect = imgW / imgH;

      if (mode === 'contain') {
        let canvasW = imgW;
        let canvasH = imgH;
        if (imgAspect > aspect) {
          canvasW = imgW;
          canvasH = Math.round(imgW / aspect);
        } else {
          canvasH = imgH;
          canvasW = Math.round(imgH * aspect);
        }
        const canvas = document.createElement('canvas');
        canvas.width = Math.max(1, canvasW);
        canvas.height = Math.max(1, canvasH);
        const ctx = canvas.getContext('2d');
        if (!ctx) return img;
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';
        const dx = Math.round((canvasW - imgW) / 2);
        const dy = Math.round((canvasH - imgH) / 2);
        ctx.drawImage(img, dx, dy);
        return canvas;
      }

      if (mode === 'cover') {
        let canvasW = imgW;
        let canvasH = imgH;
        let sx = 0;
        let sy = 0;
        let sW = imgW;
        let sH = imgH;

        if (imgAspect > aspect) {
          canvasH = imgH;
          canvasW = Math.round(imgH * aspect);
          sW = canvasW;
          sx = Math.round((imgW - sW) / 2);
        } else {
          canvasW = imgW;
          canvasH = Math.round(imgW / aspect);
          sH = canvasH;
          sy = Math.round((imgH - sH) / 2);
        }

        const canvas = document.createElement('canvas');
        canvas.width = Math.max(1, canvasW);
        canvas.height = Math.max(1, canvasH);
        const ctx = canvas.getContext('2d');
        if (!ctx) return img;
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';
        ctx.drawImage(img, sx, sy, sW, sH, 0, 0, canvasW, canvasH);
        return canvas;
      }

      return img;
    };

    const estimateQuadSize = (quad) => {
      if (!quad || quad.length !== 4) {
        return { width: 1, height: 1 };
      }
      const edge = (a, b) => Math.hypot(a.x - b.x, a.y - b.y);
      const width = (edge(quad[0], quad[1]) + edge(quad[3], quad[2])) / 2;
      const height = (edge(quad[0], quad[3]) + edge(quad[1], quad[2])) / 2;
      return { width: Math.max(1, width), height: Math.max(1, height) };
    };

    const getAffineTransform = (src, dst) => {
      const [s0, s1, s2] = src;
      const [d0, d1, d2] = dst;
      const denom = (s0.x * (s1.y - s2.y) + s1.x * (s2.y - s0.y) + s2.x * (s0.y - s1.y));
      if (Math.abs(denom) < 1e-6) return null;
      const a = (d0.x * (s1.y - s2.y) + d1.x * (s2.y - s0.y) + d2.x * (s0.y - s1.y)) / denom;
      const c = (d0.x * (s2.x - s1.x) + d1.x * (s0.x - s2.x) + d2.x * (s1.x - s0.x)) / denom;
      const e = (d0.x * (s1.x * s2.y - s2.x * s1.y) + d1.x * (s2.x * s0.y - s0.x * s2.y) + d2.x * (s0.x * s1.y - s1.x * s0.y)) / denom;

      const b = (d0.y * (s1.y - s2.y) + d1.y * (s2.y - s0.y) + d2.y * (s0.y - s1.y)) / denom;
      const d = (d0.y * (s2.x - s1.x) + d1.y * (s0.x - s2.x) + d2.y * (s1.x - s0.x)) / denom;
      const f = (d0.y * (s1.x * s2.y - s2.x * s1.y) + d1.y * (s2.x * s0.y - s0.x * s2.y) + d2.y * (s0.x * s1.y - s1.x * s0.y)) / denom;

      return [a, b, c, d, e, f];
    };

    const drawTriangle = (ctx, img, src, dst) => {
      const transform = getAffineTransform(src, dst);
      if (!transform) return;
      ctx.save();
      ctx.beginPath();
      ctx.moveTo(dst[0].x, dst[0].y);
      ctx.lineTo(dst[1].x, dst[1].y);
      ctx.lineTo(dst[2].x, dst[2].y);
      ctx.closePath();
      ctx.clip();
      ctx.setTransform(transform[0], transform[1], transform[2], transform[3], transform[4], transform[5]);
      ctx.drawImage(img, 0, 0);
      ctx.restore();
    };

    const drawImageToQuad = (ctx, img, quad) => {
      const w = img.width;
      const h = img.height;
      const src = [
        { x: 0, y: 0 },
        { x: w, y: 0 },
        { x: w, y: h },
        { x: 0, y: h },
      ];
      drawTriangle(ctx, img, [src[0], src[1], src[2]], [quad[0], quad[1], quad[2]]);
      drawTriangle(ctx, img, [src[0], src[2], src[3]], [quad[0], quad[2], quad[3]]);
      ctx.setTransform(1, 0, 0, 1, 0, 0);
    };

    const renderFastOutput = async (variant) => {
      const preset = state.preset?.fast?.[variant];
      if (!preset) throw new Error('Fast mode preset missing');
      const canvas = document.createElement('canvas');
      canvas.width = preset.output.w;
      canvas.height = preset.output.h;
      const ctx = canvas.getContext('2d');
      if (!ctx) throw new Error('No canvas context');

      if (!state.selectionSnapshot) {
        throw new Error('Load a selection first.');
      }

      const selectionImg = state.selectionImage || await createImageFromSnapshot(state.selectionSnapshot);
      state.selectionImage = selectionImg;

      if (preset.shadowPng) {
        const shadow = await loadImageAsset(preset.shadowPng);
        ctx.drawImage(shadow, 0, 0, canvas.width, canvas.height);
      }

      const fitMode = state.selectionFit || 'cover';
      const useContain = fitMode === 'contain' || fitMode === 'exact';
      if (preset.screenRect) {
        if (useContain) {
          drawImageContain(ctx, selectionImg, preset.screenRect);
        } else {
          drawImageCover(ctx, selectionImg, preset.screenRect);
        }
      }

      if (preset.screenQuad) {
        const quadSize = estimateQuadSize(preset.screenQuad);
        const fitCanvas = useContain
          ? createContainCanvas(selectionImg, quadSize.width, quadSize.height)
          : createCoverCanvas(selectionImg, quadSize.width, quadSize.height);
        drawImageToQuad(ctx, fitCanvas, preset.screenQuad);
      }

      if (preset.framePng) {
        const frame = await loadImageAsset(preset.framePng);
        ctx.drawImage(frame, 0, 0, canvas.width, canvas.height);
      }

      const dataUrl = canvas.toDataURL('image/png');
      return {
        mime: 'image/png',
        dataBase64: dataUrl.split(',')[1],
        width: canvas.width,
        height: canvas.height,
      };
    };

    // Device preset aspects for smart fitting
    const DEVICE_ASPECTS = {
      'iphone-16': 852 / 393,
      'iphone-16-pro': 874 / 402,
      'iphone-16-pro-max': 956 / 440,
      'iphone-16-plus': 932 / 430,
      'iphone-14-15-pro-max': 932 / 430,
      'iphone-14-15-pro': 852 / 393,
      'iphone-13-14': 844 / 390,
      'iphone-14-plus': 926 / 428,
      'iphone16': 2.15, // Preset file aspect
    };

    // Helper to check if aspect ratios match within epsilon
    const aspectsMatch = (a, b, epsilon = 0.01) => Math.abs(a - b) < epsilon;

    const getOutputDimensions = () => {
      const scale = Number(scaleSelect.value || 1);
      const viewWidth = viewport.clientWidth;
      const viewHeight = viewport.clientHeight;
      const minDimension = 2048;
      const maxDimension = state.qualityCap || QUALITY_CAPS.default;
      const aspectRatio = viewWidth / viewHeight;

      let exportWidth;
      let exportHeight;
      if (aspectRatio >= 1) {
        exportWidth = Math.max(viewWidth * scale, minDimension * scale);
        exportHeight = Math.round(exportWidth / aspectRatio);
      } else {
        exportHeight = Math.max(viewHeight * scale, minDimension * scale);
        exportWidth = Math.round(exportHeight * aspectRatio);
      }

      if (exportWidth > maxDimension || exportHeight > maxDimension) {
        const ratio = maxDimension / Math.max(exportWidth, exportHeight);
        exportWidth = Math.round(exportWidth * ratio);
        exportHeight = Math.round(exportHeight * ratio);
      }

      return { width: exportWidth, height: exportHeight, scale };
    };

    const getDesiredSnapshotScale = (selectionSize, capOverride) => {
      const safeSize = selectionSize || { width: 1, height: 1 };
      const { width: outputW, height: outputH } = getOutputDimensions();
      const outputMaxSide = Math.max(outputW, outputH);
      const rawDesired = Math.round(outputMaxSide * 1.1);
      const cap = capOverride ?? state.qualityCap ?? QUALITY_CAPS.default;
      const desiredMaxSide = Math.min(cap, rawDesired);
      const selectionMaxSide = Math.max(safeSize.width, safeSize.height, 1);
      const scale = desiredMaxSide / selectionMaxSide;
      return {
        scale: Math.max(0.1, scale),
        capped: rawDesired > cap,
        desiredMaxSide,
        outputMaxSide,
      };
    };

    const loadSelection = async () => {
      if (state.loadingSelection) return;
      state.loadingSelection = true;
      state.selectionToken = (state.selectionToken || 0) + 1;
      const currentToken = state.selectionToken;
      try {
        setStatus('Loading selection...');
        const selection = await rpc.call('selection.get');
        if (state.selectionToken !== currentToken) return;
        if (!selection.primaryId) {
          selectionPreview.src = '';
          selectionEmpty.style.display = 'block';
          state.selectionSnapshot = null;
          state.selectionImage = null;
          state.selectionMeta = null;
          state.selectionTargetAspect = null;
          state.selectionFit = 'cover';
          state.deviceMatch = null;
          state.qualityCapped = false;
          state.hqSnapshotInfo = null;
          updateQualityState(state.qualityRequested);
          return;
        }

        const meta = selection.nodes?.find((node) => node.id === selection.primaryId) || null;
        const isFrame = meta?.isFrame || meta?.type === 'frame';
        const devicePresetId = meta?.devicePresetId;
        const selectionSize = meta?.size || { width: 100, height: 100 };
        const selectionAspect = selectionSize.height / selectionSize.width;

        // Store metadata
        state.selectionMeta = meta ? {
          type: meta.type,
          size: meta.size,
          devicePresetId,
          isFrame
        } : null;

        // Determine best fit mode based on device preset matching
        const targetAspect = getTargetScreenAspect(devicePresetId) ?? 2.15;
        let fitMode = 'cover'; // Default for non-frames
        let matchQuality = null;

        if (isFrame) {
          if (devicePresetId) {
            // Frame has device preset - check if it matches the mockup device
            const presetAspect = DEVICE_ASPECTS[devicePresetId];
            if (presetAspect && aspectsMatch(presetAspect, targetAspect)) {
              fitMode = 'exact';
              matchQuality = 'perfect';
            } else {
              fitMode = 'contain'; // Different device, use contain to preserve design
              matchQuality = 'compatible';
            }
          } else {
            // Frame without device preset - check if dimensions match
            if (aspectsMatch(selectionAspect, targetAspect)) {
              fitMode = 'exact';
              matchQuality = 'aspect-match';
            } else {
              fitMode = 'contain';
              matchQuality = 'frame';
            }
          }
        } else {
          // Non-frame (image, group, etc.) - use cover for best visual
          fitMode = 'cover';
          matchQuality = 'non-frame';
        }

        state.selectionFit = fitMode;
        state.deviceMatch = matchQuality;
        state.selectionTargetAspect = targetAspect;

        // Use a fast preview snapshot first, then upgrade in background if needed
        const previewCap = Math.min(state.qualityCap || QUALITY_CAPS.default, PREVIEW_CAP);
        const hqInfo = getDesiredSnapshotScale(selectionSize, state.qualityCap);
        const previewInfo = getDesiredSnapshotScale(selectionSize, previewCap);
        state.qualityCapped = hqInfo.capped;
        updateQualityState(state.qualityRequested);

        const snapshot = await rpc.call('export.snapshot', {
          nodeId: selection.primaryId,
          scale: previewInfo.scale,
          maxDim: previewCap,
          allowUpscale: true,
          format: 'png',
          background: 'transparent',
          includeFrameFill: true,
          clipToBounds: isFrame,
        });
        if (state.selectionToken !== currentToken) return;

        state.selectionSnapshot = snapshot;
        selectionPreview.src = `data:${snapshot.mime};base64,${snapshot.dataBase64}`;
        selectionEmpty.style.display = 'none';
        viewportOverlay.style.display = 'none';
        state.output = null;

        state.selectionImage = await createImageFromSnapshot(snapshot);
        if (state.selectionToken !== currentToken) return;
        if (!state.screenMesh && state.model) {
          state.screenMesh = findScreenMesh(state.model);
        }
        if (state.screenMesh) {
          state.modelScreenAspect = getScreenAspect(state.screenMesh) || state.modelScreenAspect;
        }
        if (!state.screenMesh) {
          setStatus('Screen mesh not detected. Try a different device model.');
          return;
        }
        const renderAspect = state.modelScreenAspect || targetAspect;
        const texture = await createTextureFromSnapshot(snapshot, state.selectionFit, renderAspect);
        state.selectionTexture = texture;
        const targets = state.screenMeshTargets?.length ? state.screenMeshTargets : state.screenMesh;
        applyTextureToMeshes(targets, texture);

        // Update status with match quality indicator
        let baseStatus = '';
        if (matchQuality === 'perfect') {
          baseStatus = '✅ Perfect fit! Device frame matches mockup.';
        } else if (matchQuality === 'aspect-match') {
          baseStatus = '✅ Selection loaded. Aspect ratio matches.';
        } else if (matchQuality === 'compatible') {
          baseStatus = 'Selection loaded. Using contain mode for different device.';
        } else if (isFrame) {
          baseStatus = 'Selection loaded.';
        } else {
          baseStatus = 'Selection loaded. Tip: use a Device Frame for best results.';
        }
        setStatus(baseStatus);

        const shouldUpgrade =
          (state.qualityCap || QUALITY_CAPS.default) > previewCap && hqInfo.scale > previewInfo.scale * 1.05;
        state.hqSnapshotInfo = shouldUpgrade
          ? {
            nodeId: selection.primaryId,
            scale: hqInfo.scale,
            maxDim: state.qualityCap,
            isFrame,
            renderAspect,
            baseStatus,
            token: currentToken,
          }
          : null;
      } catch (error) {
        setStatus(error.message);
      } finally {
        state.loadingSelection = false;
      }
    };

    const ensureHighQualitySnapshot = async () => {
      const info = state.hqSnapshotInfo;
      if (!info) return;
      if (state.selectionToken !== info.token) {
        state.hqSnapshotInfo = null;
        return;
      }
      try {
        setStatus('Preparing high quality texture...');
        const hqSnapshot = await rpc.call('export.snapshot', {
          nodeId: info.nodeId,
          scale: info.scale,
          maxDim: info.maxDim,
          allowUpscale: true,
          format: 'png',
          background: 'transparent',
          includeFrameFill: true,
          clipToBounds: info.isFrame,
        });
        if (state.selectionToken !== info.token) {
          state.hqSnapshotInfo = null;
          return;
        }
        state.selectionSnapshot = hqSnapshot;
        selectionPreview.src = `data:${hqSnapshot.mime};base64,${hqSnapshot.dataBase64}`;
        state.output = null;
        state.selectionImage = await createImageFromSnapshot(hqSnapshot);
        if (state.selectionToken !== info.token) {
          state.hqSnapshotInfo = null;
          return;
        }
        const hqTexture = await createTextureFromSnapshot(hqSnapshot, state.selectionFit, info.renderAspect);
        state.selectionTexture = hqTexture;
        if (state.screenMesh) {
          const targets = state.screenMeshTargets?.length ? state.screenMeshTargets : state.screenMesh;
          applyTextureToMeshes(targets, hqTexture);
        }
        if (info.baseStatus) {
          setStatus(info.baseStatus);
        }
      } catch (error) {
        if (state.selectionToken === info.token) {
          setStatus(error.message);
        }
      } finally {
        state.hqSnapshotInfo = null;
      }
    };

    const generateOutput = async () => {
      if (state.hqSnapshotInfo) {
        await ensureHighQualitySnapshot();
      }
      if (state.forceFastMode) {
        return renderFastOutput(state.forceFastMode);
      }
      if (state.preset?.defaultMode === 'fast' || state.preset?.ui?.fastModeDefault) {
        return renderFastOutput(getFallbackVariant());
      }
      if (!state.renderer) return null;

      const viewWidth = viewport.clientWidth;
      const viewHeight = viewport.clientHeight;
      const { width: exportWidth, height: exportHeight } = getOutputDimensions();

      // Temporarily disable pixel ratio for export (we're already scaling)
      const originalPixelRatio = state.renderer.getPixelRatio();
      state.renderer.setPixelRatio(1);

      state.renderer.setSize(exportWidth, exportHeight, false);
      state.camera.aspect = exportWidth / exportHeight;
      state.camera.updateProjectionMatrix();
      render();

      const dataUrl = state.renderer.domElement.toDataURL('image/png');

      // Restore original settings
      state.renderer.setPixelRatio(originalPixelRatio);
      state.renderer.setSize(viewWidth, viewHeight, false);
      state.camera.aspect = viewWidth / viewHeight;
      state.camera.updateProjectionMatrix();
      render();

      return {
        mime: 'image/png',
        dataBase64: dataUrl.split(',')[1],
        width: exportWidth,
        height: exportHeight,
      };
    };

    const handleGenerate = async () => {
      if (!state.selectionSnapshot) {
        setStatus('Load a selection first.');
        return;
      }
      const output = await generateOutput();
      if (!output) {
        setStatus('Failed to generate output.');
        return;
      }
      state.output = output;
      setStatus('Mockup generated.');
    };

    const handleInsert = async () => {
      if (!state.output) {
        if (!state.selectionSnapshot) {
          setStatus('Load a selection first.');
          return;
        }
        state.output = await generateOutput();
        if (!state.output) {
          setStatus('Failed to generate output.');
          return;
        }
      }
      try {
        await rpc.call('document.insertImage', {
          dataBase64: state.output.dataBase64,
          mime: state.output.mime,
          width: state.output.width,
          height: state.output.height,
          name: 'MockRocket Mockup',
        });
        setStatus('Inserted into canvas.');
      } catch (error) {
        setStatus(error.message);
      }
    };

    const handleDownload = async () => {
      if (!state.output) {
        if (!state.selectionSnapshot) {
          setStatus('Load a selection first.');
          return;
        }
        state.output = await generateOutput();
        if (!state.output) {
          setStatus('Failed to generate output.');
          return;
        }
      }
      try {
        await rpc.call('fs.saveFile', {
          suggestedName: 'mockrocket-mockup.png',
          mime: state.output.mime,
          dataBase64: state.output.dataBase64,
        });
        setStatus('Saved file.');
      } catch (error) {
        setStatus(error.message);
      }
    };

    const handlePointerDown = (event) => {
      state.dragging = true;
      state.lastX = event.clientX;
      state.lastY = event.clientY;
      glCanvas.classList.add('dragging');
    };

    const handlePointerMove = (event) => {
      if (!state.dragging) return;
      const dx = event.clientX - state.lastX;
      const dy = event.clientY - state.lastY;
      state.lastX = event.clientX;
      state.lastY = event.clientY;
      state.rotationY += dx * 0.005;
      state.rotationX += dy * 0.005;
      state.rotationX = Math.max(-1.2, Math.min(0.2, state.rotationX));
    };

    const handlePointerUp = () => {
      state.dragging = false;
      glCanvas.classList.remove('dragging');
    };

    document.querySelectorAll('.icon-btn').forEach((btn) => {
      btn.addEventListener('click', () => {
        const mode = btn.dataset.rot;
        if (mode === 'front') {
          state.rotationX = 0;
          state.rotationY = 0;
        }
        if (mode === 'flat') {
          state.rotationX = -1.1;
          state.rotationY = 0;
        }
        if (mode === 'tilt') {
          state.rotationX = -0.4;
          state.rotationY = -0.5;
        }
        if (mode === 'perspective') {
          state.rotationX = -0.6;
          state.rotationY = 0.7;
        }
        render();
      });
    });

    // Fit mode button handlers
    const fitIndicator = document.getElementById('fitIndicator');
    const fitButtons = document.querySelectorAll('.fit-btn');

    const updateFitModeUI = () => {
      fitButtons.forEach((btn) => {
        const mode = btn.dataset.fit;
        if (mode === state.selectionFit) {
          btn.classList.add('active');
        } else {
          btn.classList.remove('active');
        }
      });

      // Update fit indicator
      if (state.deviceMatch) {
        fitIndicator.style.display = 'block';
        if (state.deviceMatch === 'perfect') {
          fitIndicator.className = 'fit-indicator-perfect';
          fitIndicator.textContent = '✅ Perfect fit';
        } else if (state.deviceMatch === 'aspect-match') {
          fitIndicator.className = 'fit-indicator-good';
          fitIndicator.textContent = '✓ Aspect ratio matches';
        } else if (state.deviceMatch === 'compatible') {
          fitIndicator.className = 'fit-indicator-info';
          fitIndicator.textContent = 'Different device';
        } else if (state.deviceMatch === 'frame') {
          fitIndicator.className = 'fit-indicator-info';
          fitIndicator.textContent = 'Frame selected';
        } else {
          fitIndicator.style.display = 'none';
        }
      } else {
        fitIndicator.style.display = 'none';
      }
    };

    const applyFitMode = async (mode) => {
      state.selectionFit = mode;
      updateFitModeUI();

      // Re-apply texture with new fit mode if we have a selection
      if (state.selectionSnapshot && state.screenMesh) {
        try {
          state.selectionImage = state.selectionImage || await createImageFromSnapshot(state.selectionSnapshot);
          const targetAspect = state.selectionTargetAspect || getTargetScreenAspect(state.selectionMeta?.devicePresetId);
          const renderAspect =
            state.modelScreenAspect || getScreenAspect(state.screenMesh) || targetAspect;
          const texture = await createTextureFromSnapshot(state.selectionSnapshot, mode, renderAspect);
          state.selectionTexture = texture;
          const targets = state.screenMeshTargets?.length ? state.screenMeshTargets : state.screenMesh;
          applyTextureToMeshes(targets, texture);
          state.output = null; // Invalidate cached output
          setStatus(`Fit mode: ${mode}`);
        } catch (error) {
          setStatus(error.message);
        }
      }
    };

    fitButtons.forEach((btn) => {
      btn.addEventListener('click', () => {
        const mode = btn.dataset.fit;
        applyFitMode(mode);
      });
    });

    const refreshSelectionForQuality = async () => {
      state.output = null;
      if (!state.selectionMeta) return;
      setStatus('Updating selection for quality...');
      await loadSelection();
      updateFitModeUI();
    };

    const applyModelSelection = async (modelId) => {
      const config = MODEL_CONFIG_MAP[modelId] || MODEL_CONFIG_MAP.iphone_16_free || MODEL_CONFIGS[0];
      if (!config) return;
      state.activeModelId = config.id;
      state.activeModelConfig = config;
      if (deviceSelect && deviceSelect.value !== config.id) {
        deviceSelect.value = config.id;
      }
      if (config.screenConfigId !== state.screenConfigId || !state.preset) {
        await loadPreset(config.screenConfigId);
      }
      await loadModel(config);
      updateCamera();
      if (state.selectionMeta) {
        await refreshSelectionForQuality();
      }
    };

    document.getElementById('loadSelection').addEventListener('click', async () => {
      await loadSelection();
      updateFitModeUI();
    });
    document.getElementById('refreshSelection').addEventListener('click', async () => {
      await loadSelection();
      updateFitModeUI();
    });
    scaleSelect.addEventListener('change', async () => {
      await refreshSelectionForQuality();
    });
    if (qualitySelect) {
      qualitySelect.addEventListener('change', async () => {
        updateQualityState(qualitySelect.value);
        await refreshSelectionForQuality();
      });
    }
    if (deviceSelect) {
      deviceSelect.addEventListener('change', async () => {
        await applyModelSelection(deviceSelect.value);
      });
    }
    document.getElementById('download').addEventListener('click', handleDownload);
    document.getElementById('insert').addEventListener('click', handleInsert);

    glCanvas.addEventListener('pointerdown', handlePointerDown);
    window.addEventListener('pointermove', handlePointerMove);
    window.addEventListener('pointerup', handlePointerUp);

    const init = async () => {
      setupScene();
      const initialModelId = (deviceSelect && deviceSelect.value) || state.activeModelId;
      state.activeModelId = initialModelId;
      state.activeModelConfig = MODEL_CONFIG_MAP[initialModelId] || MODEL_CONFIG_MAP.iphone_16_free || MODEL_CONFIGS[0];
      try {
        await loadPreset(state.activeModelConfig?.screenConfigId || 'iphone16');
      } catch (error) {
        console.error('Failed to load preset', error);
        setStatus('Failed to load preset. Using defaults.');
      }
      await loadModel(state.activeModelConfig);
      updateCamera();
      animate();
    };

    init();

    window.addEventListener('resize', updateCamera);
  </script>
</body>

</html>
